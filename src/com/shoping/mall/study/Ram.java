package com.shoping.mall.study;

public class Ram {

	/**
	 * 为了使垃圾回收器可以正常释放程序所占用的内存，在编写代码的时候就一定要注意尽量避免出现内存泄漏的情况
	 * （通常都是由于全局成员变量持有对象引用所导致的），并且在适当的时候去释放对象引用。
	 * 对于大多数的应用程序而言，后面其它的事情就可以都交给垃圾回收器去完成了，如果一个对象的引用不再被其它对象所持有
	 * ，那么系统就会将这个对象所分配的内存进行回收。
	 */

	/**
	 * 节制地使用Service
	 * 
	 * 如果应用程序当中需要使用Service来执行后台任务的话，请一定要注意只有当任务正在执行的时候才应该让Service运行起来。另外，
	 * 当任务执行完之后去停止Service的时候，要小心Service停止失败导致内存泄漏的情况。
	 * 
	 * 当我们启动一个Service时，系统会倾向于将这个Service所依赖的进程进行保留，这样就会导致这个进程变得非常消耗内存。并且，系统可以在LRU
	 * cache当中缓存的进程数量也会减少，导致切换应用程序的时候耗费更多性能。严重的话，甚至有可能会导致崩溃，
	 * 因为系统在内存非常吃紧的时候可能已无法维护所有正在运行的Service所依赖的进程了。
	 * 
	 * 为了能够控制Service的生命周期，Android官方推荐的最佳解决方案就是使用IntentService，
	 * 这种Service的最大特点就是当后台任务执行结束后会自动停止，从而极大程度上避免了Service内存泄漏的可能性。
	 * 
	 * 让一个Service在后台一直保持运行，即使它并不执行任何工作，这是编写Android程序时最糟糕的做法之一。
	 * 所以Android官方极度建议开发人员们不要过于贪婪
	 * ，让Service在后台一直运行，这不仅可能会导致手机和程序的性能非常低下，而且被用户发现了之后也有可能直接导致我们的软件被卸载
	 * （我个人就会这么做）。
	 */

	/**
	 * 当界面不可见时释放内存
	 * 
	 * 当用户打开了另外一个程序，我们的程序界面已经不再可见的时候，我们应当将所有和界面相关的资源进行释放。
	 * 在这种场景下释放资源可以让系统缓存后台进程的能力显著增加，因此也会让用户体验变得更好。
	 * 
	 * 那么我们如何才能知道程序界面是不是已经不可见了呢？其实很简单，只需要在Activity中重写onTrimMemory()方法，
	 * 然后在这个方法中监听TRIM_MEMORY_UI_HIDDEN这个级别
	 * ，一旦触发了之后就说明用户已经离开了我们的程序，那么此时就可以进行资源释放操作了，如下所示：
	 * 
	 * @Override public void onTrimMemory(int level) {
	 *           super.onTrimMemory(level); switch (level) { case
	 *           TRIM_MEMORY_UI_HIDDEN: // 进行资源释放操作 break; } }
	 * 
	 * 
	 *           注意onTrimMemory()
	 *           方法中的TRIM_MEMORY_UI_HIDDEN回调只有当我们程序中的所有UI组件全部不可见的时候才会触发
	 *           ，这和onStop()方法还是有很大区别的，因为onStop()方法只是当一个Activity完全不可见的时候就会调用，
	 *           比如说用户打开了我们程序中的另一个Activity
	 *           。因此，我们可以在onStop()方法中去释放一些Activity相关的资源，
	 *           比如说取消网络连接或者注销广播接收器等，但是像UI相关的资源应该一直要等到onTrimMemory
	 *           (TRIM_MEMORY_UI_HIDDEN
	 *           )这个回调之后才去释放，这样可以保证如果用户只是从我们程序的一个Activity回到了另外一个Activity
	 *           ，界面相关的资源都不需要重新加载，从而提升响应速度。
	 */

	/**
	 * 当内存紧张时释放内存
	 * 
	 * 除了刚才讲的TRIM_MEMORY_UI_HIDDEN这个回调，onTrimMemory()方法还有很多种其它类型的回调，
	 * 可以在手机内存降低的时候及时通知我们。我们应该根据回调中传入的级别来去决定如何释放应用程序的资源：
	 * TRIM_MEMORY_RUNNING_MODERATE
	 * 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经有点低了，系统可能会开始根据LRU缓存规则来去杀死进程了。
	 * TRIM_MEMORY_RUNNING_LOW
	 * 表示应用程序正常运行，并且不会被杀掉。但是目前手机的内存已经非常低了，我们应该去释放掉一些不必要的资源以提升系统的性能
	 * ，同时这也会直接影响到我们应用程序的性能。 TRIM_MEMORY_RUNNING_CRITICAL
	 * 表示应用程序仍然正常运行，但是系统已经根据LRU缓存规则杀掉了大部分缓存的进程了
	 * 。这个时候我们应当尽可能地去释放任何不必要的资源，不然的话系统可能会继续杀掉所有缓存中的进程
	 * ，并且开始杀掉一些本来应当保持运行的进程，比如说后台运行的服务。
	 * 
	 * 以上是当我们的应用程序正在运行时的回调，那么如果我们的程序目前是被缓存的，则会收到以下几种类型的回调：
	 * TRIM_MEMORY_BACKGROUND
	 * 表示手机目前内存已经很低了，系统准备开始根据LRU缓存来清理进程。这个时候我们的程序在LRU缓存列表的最近位置
	 * ，是不太可能被清理掉的，但这时去释放掉一些比较容易恢复的资源能够让手机的内存变得比较充足
	 * ，从而让我们的程序更长时间地保留在缓存当中，这样当用户返回我们的程序时会感觉非常顺畅，而不是经历了一次重新启动的过程。
	 * TRIM_MEMORY_MODERATE
	 * 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的中间位置，如果手机内存还得不到进一步释放的话，那么我们的程序就有被系统杀掉的风险了。
	 * TRIM_MEMORY_COMPLETE
	 * 表示手机目前内存已经很低了，并且我们的程序处于LRU缓存列表的最边缘位置，系统会最优先考虑杀掉我们的应用程序
	 * ，在这个时候应当尽可能地把一切可以释放的东西都进行释放。
	 */

	/**
	 * 使用优化过的数据集合
	 * 
	 * Android API当中提供了一些优化过后的数据集合工具类，如SparseArray，SparseBooleanArray，
	 * 以及LongSparseArray等，使用这些API可以让我们的程序更加高效。传统Java
	 * API中提供的HashMap工具类会相对比较低效，因为它需要为每一个键值对都提供一个对象入口
	 * ，而SparseArray就避免掉了基本数据类型转换成对象数据类型的时间。
	 */

	/**
	 * 知晓内存的开支情况
	 * 
	 * 我们还应当清楚我们所使用语言的内存开支和消耗情况，并且在整个软件的设计和开发当中都应该将这些信息考虑在内。可能有一些看起来无关痛痒的写法，
	 * 结果却会导致很大一部分的内存开支，例如： 使用枚举通常会比使用静态常量要消耗两倍以上的内存，在Android开发当中我们应当尽可能地不使用枚举。
	 * 任何一个Java类，包括内部类、匿名类，都要占用大概500字节的内存空间。
	 * 任何一个类的实例要消耗12-16字节的内存开支，因此频繁创建实例也是会一定程序上影响内存的。
	 * 在使用HashMap时，即使你只设置了一个基本数据类型的键
	 * ，比如说int，但是也会按照对象的大小来分配内存，大概是32字节，而不是4字节。因此最好的办法就是像上面所说的一样，使用优化过的数据集合。
	 */

	/**
	 * 使用ProGuard简化代码
	 * 
	 * ProGuard相信大家都不会陌生，很多人都会使用这个工具来混淆代码，但是除了混淆之外，它还具有压缩和优化代码的功能。
	 * ProGuard会对我们的代码进行检索
	 * ，删除一些无用的代码，并且会对类、字段、方法等进行重命名，重命名之后的类、字段和方法名都会比原来简短很多，这样的话也就对内存的占用变得更少了。
	 */

	/**
	 * 使用多个进程
	 * 
	 * 这个技巧其实并不是非常建议使用，但它确实是一种可以帮助我们节省和管理内存的高级技巧。如果你要使用它的话一定要谨慎使用，
	 * 因为绝大多数的应用程序都不应该在多个进程当中运行的
	 * ，一旦使用不当，它甚至会增加额外的内存而不是帮我们节省内存。这个技巧比较适用于那些需要在后台去完成一项独立的任务
	 * ，和前台的功能是可以完全区分开的场景。
	 * 
	 * 这里举一个比较适合去使用多进程技巧的场景，比如说我们正在做一个音乐播放器软件，其中播放音乐的功能应该是一个独立的功能，它不需要和UI方面有任何关系
	 * ，即使软件已经关闭了也应该可以正常播放音乐。如果此时我们只使用一个进程，那么即使用户关闭了软件，已经完全由Service来控制音乐播放了，
	 * 系统仍然会将许多UI方面的内存进行保留。在这种场景下就非常适合使用两个进程，一个用于UI展示，另一个则用于在后台持续地播放音乐。
	 * 
	 * 想要实现多进程的功能也非常简单，只需要在AndroidManifest文件的应用程序组件中声明一个android:process属性就可以了，
	 * 比如说我们希望播放音乐的Service可以运行在一个单独的进程当中，就可以这样写：
	 * 
	 * 
	 * <service android:name=".PlaybackService" android:process=":background" />
	 * 
	 * 
	 * 这里指定的进程名是background，你也可以将它改成任意你喜欢的名字。需要注意的是，进程名的前面都应该加上一个冒号，
	 * 表示该进程是一个当前应用程序的私有进程。
	 */
}
